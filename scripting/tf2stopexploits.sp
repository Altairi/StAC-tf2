///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  THIS IS NOT A COMPLICATED ANTICHEAT PLUGIN.                              //
//  PEOPLE SMARTER THAN ME HAVE WRITTEN THOSE.                               //
//                                                                           //
//  SEE HERE: -> https://github.com/Silenci0/SMAC                            //
//  OR HERE:  -> https://forums.alliedmods.net/showthread.php?t=321480       //
//                                                                           //
//  Currently prevents:                                                      //
//   -> interp abuse (no interp above .1)                                    //
//   -> (hopefully) box shadows (checks a series of convars)                 //
//   -> clients using turn binds (using playerruncmd)                        //
//                                                                           //
//  Currently notifies of:                                                   //
//   -> cmdrate pingmasking (if cmdrate is > 60 or has nonnumerical chars)   //
//                                                                           //
//  Todo (may not be possible):                                              //
//   -> fix spy decloak exploit                                              //
//   -> fix other sv pure stuff (flat / invisible textures)                  //
//   -> fix sniper scope removal exploit                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#pragma semicolon 1

#include <sourcemod>
#include <color_literals>
#include <regex>
#include <entity_prop_stocks>
#undef REQUIRE_PLUGIN
#include <soap_tournament>
#include <updater>

#define PLUGIN_VERSION "1.1.6"
#define UPDATE_URL "https://raw.githubusercontent.com/stephanieLGBT/tf2-stopexploits/master/updatefile.txt"
public Plugin myinfo =
{
    name             =  "Basic Exploit Prevention",
    author           =  "Originally by: Miggy, Mizx, Dr.McKay. Rewritten by Stephanie",
    description      =  "Prevents some common exploits in TF2 (orig. forked from IntegriTF2)",
    version          =   PLUGIN_VERSION,
    url              =  "https://steph.anie.dev/"
}

Handle:g_hSetHookSpawn;
Handle:findSOAP;
Handle:findMGE;
bool:hookSpawn = true;
turnTimes[MAXPLAYERS+1];
Float:tickinterv;

public OnPluginStart()
{
    checkSoapAndMGE();
    RegAdminCmd("sm_forcecheck", ForceCheck, ADMFLAG_ROOT, "Force check client convars for anticheat stuff");
    HookEvent("player_spawn", OnPlayerSpawn);
    // wait 15 secs to start checking clients after startup
    CreateTimer(15.0, Timer_CheckClientConVars);
    // get tick interval
    Float:tickinterv = GetTickInterval();
}

public OnMapStart()
{
    checkSoapAndMGE();
}

public OnLibraryAdded(const String:name[])
{
    if (StrEqual(name, "updater"))
    {
        Updater_AddPlugin(UPDATE_URL);
    }
}

checkSoapAndMGE()
{
    // -> DETECT SOAP DM AND OR MGEMOD as they both have rapid spawns that can bring a server to its knees if we hook spawns while either are active!
    Handle:findSOAP = FindPluginByFile("soap_tf2dm.smx");
    // if we can find soap...
    if (findSOAP != INVALID_HANDLE)
    {
        //...then check if it's actually running!
        if (GetPluginStatus(findSOAP) == Plugin_Running)
        {
            // if it is, DON'T hook spawns
            hookSpawn = false;
        }
    }

    Handle:findMGE = FindPluginByFile("mgemod.smx");
    // if we can find mgemod...
    if (findMGE != INVALID_HANDLE)
    {
        //...then check if it's actually running!
        if (GetPluginStatus(findMGE) == Plugin_Running)
        {
            // if it is, DON'T hook spawns
            hookSpawn = false;
        }
    }
}

public OnClientPostAdminCheck(client)
{
    // query convars on player connect
    LogMessage("[BasicExploitPrevention] %N joined. Checking cvars", client);
    QueryAllConvars(client);
    turnTimes[client] = 0;
}

public Action ForceCheck (int client, int args)
{
    QueryAllConvarsAllClients();
    ReplyToCommand(client, "Forcibly checking cvars.");
}

public void SOAP_StartDeathMatching()
{
    hookSpawn = false;
    delete g_hSetHookSpawn;
}

public void SOAP_StopDeathMatching()
{
    hookSpawn = true;
    // wait 7.5 seconds to start hooking spawns for cvar checking
    // (avoids hooking first spawns when tournament starts but avoids a race condition with soap spawning people and immediately querying convars)
    delete g_hSetHookSpawn;
    g_hSetHookSpawn = CreateTimer(7.5, setHookSpawn, TIMER_FLAG_NO_MAPCHANGE);
}

public Action setHookSpawn(Handle timer)
{
    // this is needed to prevent the above race condition
    QueryAllConvarsAllClients();
    hookSpawn = true;
    g_hSetHookSpawn = null;
}

public Action OnPlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
    if (hookSpawn)
    {
        new client = GetClientOfUserId(GetEventInt(Handle:event, "userid"));
        LogMessage("[BasicExploitPrevention] %N spawned. checking cvars", client);
        QueryAllConvars(client);
    }
}

public Action OnPlayerRunCmd(
    int client,
    int& buttons,
    int& impulse,
    float vel[3],
    float angles[3],
    int& weapon,
    int& subtype,
    int& cmdnum,
    int& tickcount,
    int& seed,
    int mouse[2]
    )
{
    if (((buttons & IN_LEFT) == IN_LEFT) || ((buttons & IN_RIGHT) == IN_RIGHT))
    {
        turnTimes[client]++;
        new Float:turnSec = turnTimes[client] * tickinterv;
        LogMessage("detected turn bind on player [%L] for [%f] seconds", client, turnSec);
        if (turnSec > 1.0)
        {
            KickClient(client, "Usage of +left and/or +right is not allowed. Autokicked");
            LogMessage("[BasicExploitPrevention] Player %N was using turn binds! Kicked from server.", client);
            PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Player %N was using turn binds! " ... COLOR_PALEGREEN ... "Kicked from server.", client);
        }
    }
}

public interpQ(QueryCookie cookie, int client, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue)
{
    if (client == 0 || !IsClientInGame(client))
    {
        return;
    }
    else if (result != ConVarQuery_Okay)
    {
        PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... "Unable to check CVar " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ... "on player %N.", cvarName, client);
        LogMessage("[BasicExploitPrevention] Unable to check CVar %s on player %N!", cvarName, client);
    }
    // cl_interp needs to be at or BELOW tf2's default settings
    else if (StringToFloat(cvarValue) > 0.100000)
    {
        KickClient(client, "CVar %s = %s, outside reasonable bounds. Change it to .1 at most", cvarName, cvarValue);
        LogMessage("[BasicExploitPrevention] Player %N was using CVar %s = %s, indicating interp explotation. Kicked from server.", client, cvarName, cvarValue);
        PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Player %N was using CVar " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ..." = " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ... ", indicating interp explotation." ... COLOR_PALEGREEN ... "Kicked from server.", client, cvarName, cvarValue);
    }
}

public cmdrateQ(QueryCookie cookie, int client, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue)
{
    if (client == 0 || !IsClientInGame(client))
    {
        return;
    }
    else if (result != ConVarQuery_Okay)
    {
        PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... "Unable to check CVar " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ... "on player %N.", cvarName, client);
        LogMessage("[BasicExploitPrevention] Unable to check CVar %s on player %N!", cvarName, client);
    }
    else if (!cvarValue[0])
    {
        LogMessage("[BasicExploitPrevention] Null string returned as cvar result!");
    }
    // cl_cmdrate needs to be above 60 AND not have any non numerical chars (xcept the . sign if its a float) in it because otherwise player ping gets messed up on the scoreboard
    else if ((StringToFloat(cvarValue) < 60) || SimpleRegexMatch(cvarValue, "^\\d*\\.?\\d*$") <= 0)
    {
        LogMessage("[BasicExploitPrevention] Player %N is using CVar %s = %s, possibly ping-masking or rate exploiting!", client, cvarName, cvarValue);
    }
}

public shadowsQ(QueryCookie cookie, int client, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue)
{
    if (client == 0 || !IsClientInGame(client))
    {
        return;
    }
    else if (result != ConVarQuery_Okay)
    {
        PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... "Unable to check CVar " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ... "on player %N.", cvarName, client);
        LogMessage("[BasicExploitPrevention] Unable to check CVar %s on player %N!", cvarName, client);
    }
    //
    else if (StringToInt(cvarValue) != 0)
    {
        QueryClientConVar(client, "cl_blobbyshadows", ConVarQueryFinished:blobbyShadowsQ);
    }
}

public blobbyShadowsQ(QueryCookie cookie, int client, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue)
{
    if (client == 0 || !IsClientInGame(client))
    {
        return;
    }
    else if (result != ConVarQuery_Okay)
    {
        PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... "Unable to check CVar " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ... "on player %N.", cvarName, client);
        LogMessage("[BasicExploitPrevention] Unable to check CVar %s on player %N!", cvarName, client);
    }
    //
    else if (StringToInt(cvarValue) != 0)
    {
        QueryClientConVar(client, "r_shadowrendertotexture", ConVarQueryFinished:shadowRenderQ);
    }
}

public shadowRenderQ(QueryCookie cookie, int client, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue)
{
    if (client == 0 || !IsClientInGame(client))
    {
        return;
    }
    else if (result != ConVarQuery_Okay)
    {
        PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... "Unable to check CVar " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ... "on player %N.", cvarName, client);
        LogMessage("[BasicExploitPrevention] Unable to check CVar %s on player %N!", cvarName, client);
    }
    //
    else if (StringToInt(cvarValue) != 0)
    {
        QueryClientConVar(client, "r_shadowmaxrendered ", ConVarQueryFinished:shadowRenderMaxQ);
    }
}

public shadowRenderMaxQ(QueryCookie cookie, int client, ConVarQueryResult result, const char[] cvarName, const char[] cvarValue)
{
    if (client == 0 || !IsClientInGame(client))
    {
        return;
    }
    else if (result != ConVarQuery_Okay)
    {
        PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... "Unable to check CVar " ... COLOR_MEDIUMPURPLE ... "%s" ... COLOR_WHITE ... "on player %N.", cvarName, client);
        LogMessage("[BasicExploitPrevention] Unable to check CVar %s on player %N!", cvarName, client);
    }
    //
    else if (StringToInt(cvarValue) >= 12)
    {
        KickClient(client, "Player %N was using box shadows!", client);
        PrintColoredChatAll(COLOR_HOTPINK ... "[BasicExploitPrevention]" ... COLOR_WHITE ... " Player %N was using BOX SHADOWS! " ... COLOR_PALEGREEN ... "Kicked from server.", client);
        LogMessage("[BasicExploitPrevention] Player %N was using box shadows!", client);
    }
}

QueryAllConvars(int client)
{

    QueryClientConVar(client, "cl_interp", ConVarQueryFinished:interpQ);
    QueryClientConVar(client, "cl_cmdrate", ConVarQueryFinished:cmdrateQ);
    // chain
    QueryClientConVar(client, "r_shadows", ConVarQueryFinished:shadowsQ);
}

QueryAllConvarsAllClients()
{
    LogMessage("[BasicExploitPrevention] Querying all clients");
    for (new client = 1; client <= MaxClients; client++)
    {
        if (IsClientInGame(client) && !IsFakeClient(client))
        {
            QueryAllConvars(client);
        }
    }
}

public Action Timer_CheckClientConVars(Handle:timer)
{
    // iterate thru clients
    QueryAllConvarsAllClients();
    // check randomly (every 1 - 5 minutes) for violating players, then recheck with a new random value
    CreateTimer(GetRandomFloat(60.0, 300.0), Timer_CheckClientConVars);
}
